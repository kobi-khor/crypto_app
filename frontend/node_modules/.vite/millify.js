import {
  __commonJS
} from "./chunk-DNTJHIQS.js";

// node_modules/millify/dist/options.js
var require_options = __commonJS({
  "node_modules/millify/dist/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOptions = void 0;
    exports.defaultOptions = {
      decimalSeparator: ".",
      lowercase: false,
      precision: 1,
      space: false,
      units: [
        "",
        "K",
        "M",
        "B",
        "T",
        "P",
        "E"
      ]
    };
  }
});

// node_modules/millify/dist/utils.js
var require_utils = __commonJS({
  "node_modules/millify/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.roundTo = exports.parseValue = void 0;
    function parseValue(value) {
      const val = parseFloat(value.toString());
      if (isNaN(val)) {
        throw new Error(`Input value is not a number`);
      }
      if (val > Number.MAX_SAFE_INTEGER || val < Number.MIN_SAFE_INTEGER) {
        throw new RangeError("Input value is outside of safe integer range");
      }
      return val;
    }
    exports.parseValue = parseValue;
    function roundTo(value, precision) {
      if (!Number.isFinite(value)) {
        throw new Error("Input value is not a finite number");
      }
      if (!Number.isInteger(precision) || precision < 0) {
        throw new Error("Precision is not a positive integer");
      }
      if (Number.isInteger(value)) {
        return value;
      }
      return parseFloat(value.toFixed(precision));
    }
    exports.roundTo = roundTo;
  }
});

// node_modules/millify/dist/millify.js
var require_millify = __commonJS({
  "node_modules/millify/dist/millify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.millify = void 0;
    var options_1 = require_options();
    var utils_1 = require_utils();
    var DIGIT_GROUPING_BASE = 1e3;
    function* divider(value) {
      let denominator = DIGIT_GROUPING_BASE;
      while (true) {
        const result = value / denominator;
        if (result < 1) {
          return;
        }
        yield result;
        denominator *= DIGIT_GROUPING_BASE;
      }
    }
    function millify(value, options) {
      var _a;
      const opts = options ? Object.assign(Object.assign({}, options_1.defaultOptions), options) : options_1.defaultOptions;
      if (!Array.isArray(opts.units) || !opts.units.length) {
        throw new Error("Option `units` must be a non-empty array");
      }
      let val = utils_1.parseValue(value);
      const prefix = val < 0 ? "-" : "";
      val = Math.abs(val);
      let unitIndex = 0;
      for (const result of divider(val)) {
        val = result;
        unitIndex += 1;
      }
      const unitIndexOutOfRange = unitIndex >= opts.units.length;
      if (unitIndexOutOfRange) {
        return value.toString();
      }
      let rounded = utils_1.roundTo(val, opts.precision);
      for (const result of divider(rounded)) {
        rounded = result;
        unitIndex += 1;
      }
      const unit = (_a = opts.units[unitIndex]) !== null && _a !== void 0 ? _a : "";
      const suffix = opts.lowercase ? unit.toLowerCase() : unit;
      const space = opts.space ? " " : "";
      const formatted = rounded.toString().replace(options_1.defaultOptions.decimalSeparator, opts.decimalSeparator);
      return `${prefix}${formatted}${space}${suffix}`;
    }
    exports.millify = millify;
    exports.default = millify;
  }
});

// dep:millify
var millify_default = require_millify();
export {
  millify_default as default
};
//# sourceMappingURL=millify.js.map
